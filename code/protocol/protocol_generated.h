// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_PROTOCOL_FTS_H_
#define FLATBUFFERS_GENERATED_PROTOCOL_FTS_H_

#include "flatbuffers/flatbuffers.h"

namespace fts {

struct LogEntry;

struct GameInfoBroadcast;

struct GameServerLogInterval;

struct Message;

enum class Data : uint8_t {
  NONE = 0,
  LogEntry = 1,
  GameInfoBroadcast = 2,
  GameServerLogInterval = 3,
  MIN = NONE,
  MAX = GameServerLogInterval
};

inline const char **EnumNamesData() {
  static const char *names[] = { "NONE", "LogEntry", "GameInfoBroadcast", "GameServerLogInterval", nullptr };
  return names;
}

inline const char *EnumNameData(Data e) { return EnumNamesData()[static_cast<int>(e)]; }

template<typename T> struct DataTraits {
  static const Data enum_value = Data::NONE;
};

template<> struct DataTraits<LogEntry> {
  static const Data enum_value = Data::LogEntry;
};

template<> struct DataTraits<GameInfoBroadcast> {
  static const Data enum_value = Data::GameInfoBroadcast;
};

template<> struct DataTraits<GameServerLogInterval> {
  static const Data enum_value = Data::GameServerLogInterval;
};

inline bool VerifyData(flatbuffers::Verifier &verifier, const void *union_obj, Data type);

struct LogEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIME = 4,
    VT_CATEGORY = 6,
    VT_MESSAGE = 8
  };
  float time() const { return GetField<float>(VT_TIME, 0.0f); }
  const flatbuffers::String *category() const { return GetPointer<const flatbuffers::String *>(VT_CATEGORY); }
  const flatbuffers::String *message() const { return GetPointer<const flatbuffers::String *>(VT_MESSAGE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TIME) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CATEGORY) &&
           verifier.Verify(category()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           verifier.EndTable();
  }
};

struct LogEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(float time) { fbb_.AddElement<float>(LogEntry::VT_TIME, time, 0.0f); }
  void add_category(flatbuffers::Offset<flatbuffers::String> category) { fbb_.AddOffset(LogEntry::VT_CATEGORY, category); }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) { fbb_.AddOffset(LogEntry::VT_MESSAGE, message); }
  LogEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LogEntryBuilder &operator=(const LogEntryBuilder &);
  flatbuffers::Offset<LogEntry> Finish() {
    auto o = flatbuffers::Offset<LogEntry>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<LogEntry> CreateLogEntry(flatbuffers::FlatBufferBuilder &_fbb,
    float time = 0.0f,
    flatbuffers::Offset<flatbuffers::String> category = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  LogEntryBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_category(category);
  builder_.add_time(time);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogEntry> CreateLogEntryDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float time = 0.0f,
    const char *category = nullptr,
    const char *message = nullptr) {
  return CreateLogEntry(_fbb, time, category ? _fbb.CreateString(category) : 0, message ? _fbb.CreateString(message) : 0);
}

struct GameInfoBroadcast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IPADDR = 4,
    VT_PORT = 6,
    VT_HOSTNAME = 8,
    VT_PROCESSID = 10
  };
  const flatbuffers::String *ipaddr() const { return GetPointer<const flatbuffers::String *>(VT_IPADDR); }
  int32_t port() const { return GetField<int32_t>(VT_PORT, 0); }
  const flatbuffers::String *hostname() const { return GetPointer<const flatbuffers::String *>(VT_HOSTNAME); }
  int32_t processid() const { return GetField<int32_t>(VT_PROCESSID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_IPADDR) &&
           verifier.Verify(ipaddr()) &&
           VerifyField<int32_t>(verifier, VT_PORT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HOSTNAME) &&
           verifier.Verify(hostname()) &&
           VerifyField<int32_t>(verifier, VT_PROCESSID) &&
           verifier.EndTable();
  }
};

struct GameInfoBroadcastBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ipaddr(flatbuffers::Offset<flatbuffers::String> ipaddr) { fbb_.AddOffset(GameInfoBroadcast::VT_IPADDR, ipaddr); }
  void add_port(int32_t port) { fbb_.AddElement<int32_t>(GameInfoBroadcast::VT_PORT, port, 0); }
  void add_hostname(flatbuffers::Offset<flatbuffers::String> hostname) { fbb_.AddOffset(GameInfoBroadcast::VT_HOSTNAME, hostname); }
  void add_processid(int32_t processid) { fbb_.AddElement<int32_t>(GameInfoBroadcast::VT_PROCESSID, processid, 0); }
  GameInfoBroadcastBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameInfoBroadcastBuilder &operator=(const GameInfoBroadcastBuilder &);
  flatbuffers::Offset<GameInfoBroadcast> Finish() {
    auto o = flatbuffers::Offset<GameInfoBroadcast>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<GameInfoBroadcast> CreateGameInfoBroadcast(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ipaddr = 0,
    int32_t port = 0,
    flatbuffers::Offset<flatbuffers::String> hostname = 0,
    int32_t processid = 0) {
  GameInfoBroadcastBuilder builder_(_fbb);
  builder_.add_processid(processid);
  builder_.add_hostname(hostname);
  builder_.add_port(port);
  builder_.add_ipaddr(ipaddr);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameInfoBroadcast> CreateGameInfoBroadcastDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *ipaddr = nullptr,
    int32_t port = 0,
    const char *hostname = nullptr,
    int32_t processid = 0) {
  return CreateGameInfoBroadcast(_fbb, ipaddr ? _fbb.CreateString(ipaddr) : 0, port, hostname ? _fbb.CreateString(hostname) : 0, processid);
}

struct GameServerLogInterval FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INTERVAL = 4
  };
  float interval() const { return GetField<float>(VT_INTERVAL, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_INTERVAL) &&
           verifier.EndTable();
  }
};

struct GameServerLogIntervalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_interval(float interval) { fbb_.AddElement<float>(GameServerLogInterval::VT_INTERVAL, interval, 0.0f); }
  GameServerLogIntervalBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameServerLogIntervalBuilder &operator=(const GameServerLogIntervalBuilder &);
  flatbuffers::Offset<GameServerLogInterval> Finish() {
    auto o = flatbuffers::Offset<GameServerLogInterval>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GameServerLogInterval> CreateGameServerLogInterval(flatbuffers::FlatBufferBuilder &_fbb,
    float interval = 0.0f) {
  GameServerLogIntervalBuilder builder_(_fbb);
  builder_.add_interval(interval);
  return builder_.Finish();
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  Data data_type() const { return static_cast<Data>(GetField<uint8_t>(VT_DATA_TYPE, 0)); }
  const void *data() const { return GetPointer<const void *>(VT_DATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           VerifyData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(Data data_type) { fbb_.AddElement<uint8_t>(Message::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0); }
  void add_data(flatbuffers::Offset<void> data) { fbb_.AddOffset(Message::VT_DATA, data); }
  MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    auto o = flatbuffers::Offset<Message>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(flatbuffers::FlatBufferBuilder &_fbb,
    Data data_type = Data::NONE,
    flatbuffers::Offset<void> data = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline bool VerifyData(flatbuffers::Verifier &verifier, const void *union_obj, Data type) {
  switch (type) {
    case Data::NONE: return true;
    case Data::LogEntry: return verifier.VerifyTable(reinterpret_cast<const LogEntry *>(union_obj));
    case Data::GameInfoBroadcast: return verifier.VerifyTable(reinterpret_cast<const GameInfoBroadcast *>(union_obj));
    case Data::GameServerLogInterval: return verifier.VerifyTable(reinterpret_cast<const GameServerLogInterval *>(union_obj));
    default: return false;
  }
}

inline const fts::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<fts::Message>(buf);
}

inline bool VerifyMessageBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fts::Message>(nullptr);
}

inline void FinishMessageBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<fts::Message> root) {
  fbb.Finish(root);
}

}  // namespace fts

#endif  // FLATBUFFERS_GENERATED_PROTOCOL_FTS_H_
